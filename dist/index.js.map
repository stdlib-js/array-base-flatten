{
  "version": 3,
  "sources": ["../lib/assign.js", "../lib/main.js", "../lib/index.js"],
  "sourcesContent": ["/**\n* @license Apache-2.0\n*\n* Copyright (c) 2023 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nvar shape2strides = require( '@stdlib/ndarray-base-shape2strides' );\nvar vind2bind = require( '@stdlib/ndarray-base-vind2bind' );\nvar numel = require( '@stdlib/ndarray-base-numel' );\nvar grev = require( '@stdlib/blas-ext-base-grev' );\nvar zeros = require( '@stdlib/array-base-zeros' );\n\n\n// VARIABLES //\n\nvar MODE = 'throw';\n\n\n// FUNCTIONS //\n\n/**\n* Copies a specified number of array elements to a provided array.\n*\n* @private\n* @param {Array} x - input array\n* @param {NonNegativeInteger} N - number of elements to copy\n* @param {Collection} out - output array\n* @param {integer} stride - output array stride\n* @param {NonNegativeInteger} offset - output array offset\n*\n* @example\n* var x = [ 1, 2, 3, 4 ];\n*\n* var out = [ 0, 0, 0 ];\n* copy( x, 3, out, 1, 0 );\n*\n* var o = out;\n* // returns [ 1, 2, 3 ]\n*/\nfunction copy( x, N, out, stride, offset ) {\n\tvar i;\n\tfor ( i = 0; i < N; i++ ) {\n\t\tout[ offset ] = x[ i ];\n\t\toffset += stride;\n\t}\n}\n\n/**\n* Recursively flattens an array in lexicographic order.\n*\n* @private\n* @param {Array} x - array to flatten\n* @param {NonNegativeInteger} ndims - number of dimensions in the input array\n* @param {NonNegativeIntegerArray} shape - shape of the input array\n* @param {NonNegativeInteger} dim - dimension index\n* @param {Collection} out - output array\n* @param {integer} stride - output array stride\n* @param {NonNegativeInteger} offset - output array offset\n* @returns {NonNegativeInteger} offset for next output array element\n*/\nfunction recurseLexicographic( x, ndims, shape, dim, out, stride, offset ) {\n\tvar FLG;\n\tvar S;\n\tvar d;\n\tvar i;\n\n\t// Check whether we've reached the last dimension:\n\td = dim + 1;\n\tFLG = ( d === ndims );\n\n\tS = shape[ dim ];\n\tfor ( i = 0; i < S; i++ ) {\n\t\tif ( FLG ) {\n\t\t\tout[ offset ] = x[ i ];\n\t\t\toffset += stride;\n\t\t} else {\n\t\t\toffset = recurseLexicographic( x[ i ], ndims, shape, d, out, stride, offset ); // eslint-disable-line max-len\n\t\t}\n\t}\n\treturn offset;\n}\n\n/**\n* Flattens an array in colexicographic order.\n*\n* @private\n* @param {Array} x - array to flatten\n* @param {NonNegativeInteger} ndims - number of dimensions in the input array\n* @param {NonNegativeIntegerArray} shape - shape of the input array\n* @param {Collection} out - output array\n* @param {integer} stride - output array stride\n* @param {NonNegativeInteger} offset - output array offset\n*/\nfunction flattenColexicographic( x, ndims, shape, out, stride, offset ) {\n\tvar len;\n\tvar tmp;\n\tvar ord;\n\tvar sh;\n\tvar sx;\n\tvar j;\n\tvar i;\n\n\t// Note that, in contrast to lexicographic iteration, we cannot readily define a straightforward recursive definition for colexicographic iteration. Accordingly, we have to perform a workaround in which we first flatten in lexicographic order and then perform an out-of-place transposition to return an array in colexicographic order.\n\n\t// Determine how many elements will be in the output array:\n\tlen = numel( shape );\n\n\t// For input arrays having an arbitrary number of dimensions, first flatten in lexicographic order:\n\ttmp = zeros( len );\n\trecurseLexicographic( x, ndims, shape, 0, tmp, 1, 0 );\n\n\t// Define the memory layout:\n\tord = 'row-major';\n\n\t// Generate a stride array for lexicographic order:\n\tsx = shape2strides( shape, ord );\n\n\t// Reverse the dimensions and strides (i.e., define the shape and strides of the transpose):\n\tsh = zeros( ndims );\n\tcopy( shape, ndims, sh, 1, 0 );\n\tgrev( ndims, sh, 1 );\n\tgrev( ndims, sx, 1 );\n\n\t// Iterate over each element based on the linear **view** index (note: this has negative performance implications due to lack of data locality)...\n\tfor ( i = 0; i < len; i++ ) {\n\t\tj = vind2bind( sh, sx, 0, ord, i, MODE );\n\t\tout[ offset ] = tmp[ j ];\n\t\toffset += stride;\n\t}\n}\n\n\n// MAIN //\n\n/**\n* Flattens an n-dimensional nested array and assigns elements to a provided output array.\n*\n* ## Notes\n*\n* -   The function assumes that all nested arrays have the same length (i.e., the input array is **not** a ragged array).\n*\n* @param {Array} x - input nested array\n* @param {NonNegativeIntegerArray} shape - array shape\n* @param {boolean} colexicographic - specifies whether to flatten array values in colexicographic order\n* @param {Collection} out - output array\n* @param {integer} stride - output array stride\n* @param {NonNegativeInteger} offset - output array index offset\n* @returns {Collection} output array\n*\n* @example\n* var Float64Array = require( '@stdlib/array-float64' );\n*\n* var x = [ [ 1, 2 ], [ 3, 4 ] ];\n*\n* var out = flatten( x, [ 2, 2 ], false, new Float64Array( 4 ), 1, 0 );\n* // returns <Float64Array>[ 1, 2, 3, 4 ]\n*\n* @example\n* var Float64Array = require( '@stdlib/array-float64' );\n*\n* var x = [ [ 1, 2 ], [ 3, 4 ] ];\n*\n* var out = flatten( x, [ 2, 2 ], true, new Float64Array( 4 ), 1, 0 );\n* // returns <Float64Array>[ 1, 3, 2, 4 ]\n*/\nfunction flatten( x, shape, colexicographic, out, stride, offset ) {\n\tvar ndims = shape.length;\n\tif ( ndims === 0 ) { // 0-dimensional array\n\t\treturn out;\n\t}\n\tif ( ndims === 1 ) { // 1-dimensional array\n\t\t// For 1-dimensional arrays, we can perform a simple copy:\n\t\tcopy( x, shape[ 0 ], out, stride, offset );\n\t\treturn out;\n\t}\n\tif ( colexicographic ) {\n\t\tflattenColexicographic( x, ndims, shape, out, stride, offset );\n\t\treturn out;\n\t}\n\trecurseLexicographic( x, ndims, shape, 0, out, stride, offset );\n\treturn out;\n}\n\n\n// EXPORTS //\n\nmodule.exports = flatten;\n", "/**\n* @license Apache-2.0\n*\n* Copyright (c) 2023 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nvar numel = require( '@stdlib/ndarray-base-numel' );\nvar zeros = require( '@stdlib/array-base-zeros' );\nvar assign = require( './assign.js' );\n\n\n// MAIN //\n\n/**\n* Flattens an n-dimensional nested array.\n*\n* ## Notes\n*\n* -   The function assumes that all nested arrays have the same length (i.e., the input array is **not** a ragged array).\n*\n* @param {Array} x - input nested array\n* @param {NonNegativeIntegerArray} shape - array shape\n* @param {boolean} colexicographic - specifies whether to flatten array values in colexicographic order\n* @returns {Array} flattened array\n*\n* @example\n* var x = [ [ 1, 2 ], [ 3, 4 ] ];\n*\n* var out = flatten( x, [ 2, 2 ], false );\n* // returns [ 1, 2, 3, 4 ]\n*\n* @example\n* var x = [ [ 1, 2 ], [ 3, 4 ] ];\n*\n* var out = flatten( x, [ 2, 2 ], true );\n* // returns [ 1, 3, 2, 4 ]\n*/\nfunction flatten( x, shape, colexicographic ) {\n\tvar out = zeros( numel( shape ) );\n\treturn assign( x, shape, colexicographic, out, 1, 0 );\n}\n\n\n// EXPORTS //\n\nmodule.exports = flatten;\n", "/**\n* @license Apache-2.0\n*\n* Copyright (c) 2023 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n/**\n* Flatten an n-dimensional nested array.\n*\n* @module @stdlib/array-base-flatten\n*\n* @example\n* var flatten = require( '@stdlib/array-base-flatten' );\n*\n* var x = [ [ 1, 2 ], [ 3, 4 ] ];\n*\n* var out = flatten( x, [ 2, 2 ], false );\n* // returns [ 1, 2, 3, 4 ]\n*\n* @example\n* var flatten = require( '@stdlib/array-base-flatten' );\n*\n* var x = [ [ 1, 2 ], [ 3, 4 ] ];\n*\n* var out = flatten( x, [ 2, 2 ], true );\n* // returns [ 1, 3, 2, 4 ]\n*\n* @example\n* var Float64Array = require( '@stdlib/array-float64' );\n* var flatten = require( '@stdlib/array-base-flatten' );\n*\n* var x = [ [ 1, 2 ], [ 3, 4 ] ];\n*\n* var out = new Float64Array( 4 );\n* var y = flatten.assign( x, [ 2, 2 ], true, out, 1, 0 );\n* // returns <Float64Array>[ 1, 3, 2, 4 ]\n*\n* var bool = ( y === out );\n* // returns true\n*/\n\n// MODULES //\n\nvar setReadOnly = require( '@stdlib/utils-define-nonenumerable-read-only-property' );\nvar main = require( './main.js' );\nvar assign = require( './assign.js' );\n\n\n// MAIN //\n\nsetReadOnly( main, 'assign', assign );\n\n\n// EXPORTS //\n\nmodule.exports = main;\n"],
  "mappings": "uGAAA,IAAAA,EAAAC,EAAA,SAAAC,EAAAC,EAAA,cAsBA,IAAIC,EAAgB,QAAS,oCAAqC,EAC9DC,EAAY,QAAS,gCAAiC,EACtDC,EAAQ,QAAS,4BAA6B,EAC9CC,EAAO,QAAS,4BAA6B,EAC7CC,EAAQ,QAAS,0BAA2B,EAK5CC,EAAO,QAwBX,SAASC,EAAMC,EAAGC,EAAGC,EAAKC,EAAQC,EAAS,CAC1C,IAAI,EACJ,IAAM,EAAI,EAAG,EAAIH,EAAG,IACnBC,EAAKE,CAAO,EAAIJ,EAAG,CAAE,EACrBI,GAAUD,CAEZ,CAeA,SAASE,EAAsBL,EAAGM,EAAOC,EAAOC,EAAKN,EAAKC,EAAQC,EAAS,CAC1E,IAAIK,EACAC,EACAC,EACAC,EAOJ,IAJAD,EAAIH,EAAM,EACVC,EAAQE,IAAML,EAEdI,EAAIH,EAAOC,CAAI,EACTI,EAAI,EAAGA,EAAIF,EAAGE,IACdH,GACJP,EAAKE,CAAO,EAAIJ,EAAGY,CAAE,EACrBR,GAAUD,GAEVC,EAASC,EAAsBL,EAAGY,CAAE,EAAGN,EAAOC,EAAOI,EAAGT,EAAKC,EAAQC,CAAO,EAG9E,OAAOA,CACR,CAaA,SAASS,EAAwBb,EAAGM,EAAOC,EAAOL,EAAKC,EAAQC,EAAS,CACvE,IAAIU,EACAC,EACAC,EACAC,EACAC,EACA,EACAN,EAwBJ,IAnBAE,EAAMnB,EAAOY,CAAM,EAGnBQ,EAAMlB,EAAOiB,CAAI,EACjBT,EAAsBL,EAAGM,EAAOC,EAAO,EAAGQ,EAAK,EAAG,CAAE,EAGpDC,EAAM,YAGNE,EAAKzB,EAAec,EAAOS,CAAI,EAG/BC,EAAKpB,EAAOS,CAAM,EAClBP,EAAMQ,EAAOD,EAAOW,EAAI,EAAG,CAAE,EAC7BrB,EAAMU,EAAOW,EAAI,CAAE,EACnBrB,EAAMU,EAAOY,EAAI,CAAE,EAGbN,EAAI,EAAGA,EAAIE,EAAKF,IACrB,EAAIlB,EAAWuB,EAAIC,EAAI,EAAGF,EAAKJ,EAAGd,CAAK,EACvCI,EAAKE,CAAO,EAAIW,EAAK,CAAE,EACvBX,GAAUD,CAEZ,CAoCA,SAASgB,EAASnB,EAAGO,EAAOa,EAAiBlB,EAAKC,EAAQC,EAAS,CAClE,IAAIE,EAAQC,EAAM,OAClB,OAAKD,IAAU,EACPJ,EAEHI,IAAU,GAEdP,EAAMC,EAAGO,EAAO,CAAE,EAAGL,EAAKC,EAAQC,CAAO,EAClCF,GAEHkB,GACJP,EAAwBb,EAAGM,EAAOC,EAAOL,EAAKC,EAAQC,CAAO,EACtDF,IAERG,EAAsBL,EAAGM,EAAOC,EAAO,EAAGL,EAAKC,EAAQC,CAAO,EACvDF,EACR,CAKAV,EAAO,QAAU2B,IC1MjB,IAAAE,EAAAC,EAAA,SAAAC,EAAAC,EAAA,cAsBA,IAAIC,EAAQ,QAAS,4BAA6B,EAC9CC,EAAQ,QAAS,0BAA2B,EAC5CC,EAAS,IA6Bb,SAASC,EAASC,EAAGC,EAAOC,EAAkB,CAC7C,IAAIC,EAAMN,EAAOD,EAAOK,CAAM,CAAE,EAChC,OAAOH,EAAQE,EAAGC,EAAOC,EAAiBC,EAAK,EAAG,CAAE,CACrD,CAKAR,EAAO,QAAUI,ICJjB,IAAIK,EAAc,QAAS,uDAAwD,EAC/EC,EAAO,IACPC,EAAS,IAKbF,EAAaC,EAAM,SAAUC,CAAO,EAKpC,OAAO,QAAUD",
  "names": ["require_assign", "__commonJSMin", "exports", "module", "shape2strides", "vind2bind", "numel", "grev", "zeros", "MODE", "copy", "x", "N", "out", "stride", "offset", "recurseLexicographic", "ndims", "shape", "dim", "FLG", "S", "d", "i", "flattenColexicographic", "len", "tmp", "ord", "sh", "sx", "flatten", "colexicographic", "require_main", "__commonJSMin", "exports", "module", "numel", "zeros", "assign", "flatten", "x", "shape", "colexicographic", "out", "setReadOnly", "main", "assign"]
}
