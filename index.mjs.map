{"version":3,"file":"index.mjs","sources":["../lib/main.js"],"sourcesContent":["/**\n* @license Apache-2.0\n*\n* Copyright (c) 2023 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport shape2strides from '@stdlib/ndarray-base-shape2strides';\nimport vind2bind from '@stdlib/ndarray-base-vind2bind';\nimport numel from '@stdlib/ndarray-base-numel';\nimport grev from '@stdlib/blas-ext-base-grev';\n\n\n// VARIABLES //\n\nvar MODE = 'throw';\n\n\n// FUNCTIONS //\n\n/**\n* Copies a specified number of array elements to a provided array.\n*\n* @private\n* @param {Array} out - output array\n* @param {Array} x - input array\n* @param {NonNegativeInteger} N - number of elements to copy\n* @returns {Array} output array\n*\n* @example\n* var x = [ 1, 2, 3, 4 ];\n*\n* var out = copy( [], x, 3 );\n* // returns [ 1, 2, 3 ]\n*/\nfunction copy( out, x, N ) {\n\tvar i;\n\tfor ( i = 0; i < N; i++ ) {\n\t\tout.push( x[ i ] );\n\t}\n\treturn out;\n}\n\n/**\n* Recursively flattens an array in lexicographic order.\n*\n* @private\n* @param {Array} out - output array\n* @param {Array} x - array to flatten\n* @param {NonNegativeInteger} ndims - number of dimensions in the input array\n* @param {NonNegativeIntegerArray} shape - shape of the input array\n* @param {NonNegativeInteger} dim - dimension index\n* @returns {Array} output array\n*/\nfunction recurseLexicographic( out, x, ndims, shape, dim ) {\n\tvar FLG;\n\tvar S;\n\tvar d;\n\tvar i;\n\n\t// Check whether we've reached the last dimension:\n\td = dim + 1;\n\tFLG = ( d === ndims );\n\n\tS = shape[ dim ];\n\tfor ( i = 0; i < S; i++ ) {\n\t\tif ( FLG ) {\n\t\t\tout.push( x[ i ] );\n\t\t} else {\n\t\t\trecurseLexicographic( out, x[ i ], ndims, shape, d );\n\t\t}\n\t}\n\treturn out;\n}\n\n/**\n* Flattens an array in colexicographic order.\n*\n* @private\n* @param {Array} out - output array\n* @param {Array} x - array to flatten\n* @param {NonNegativeInteger} ndims - number of dimensions in the input array\n* @param {NonNegativeIntegerArray} shape - shape of the input array\n* @returns {Array} output array\n*/\nfunction flattenColexicographic( out, x, ndims, shape ) {\n\tvar len;\n\tvar tmp;\n\tvar ord;\n\tvar sh;\n\tvar sx;\n\tvar j;\n\tvar i;\n\n\t// Note that, in contrast to lexicographic iteration, we cannot readily define a straightforward recursive definition for colexicographic iteration. Accordingly, we have to perform a workaround in which we first flatten in lexicographic order and then perform an out-of-place transposition to return an array in colexicographic order.\n\n\t// For input arrays having an arbitrary number of dimensions, first flatten in lexicographic order:\n\ttmp = recurseLexicographic( [], x, ndims, shape, 0 );\n\n\t// Determine how many elements will be in the output array:\n\tlen = numel( shape );\n\n\t// Define the memory layout:\n\tord = 'row-major';\n\n\t// Generate a stride array for lexicographic order:\n\tsx = shape2strides( shape, ord );\n\n\t// Reverse the dimensions and strides (i.e., define the shape and strides of the transpose):\n\tsh = copy( [], shape, ndims );\n\tgrev( ndims, sh, 1 );\n\tgrev( ndims, sx, 1 );\n\n\t// Iterate over each element based on the linear **view** index (note: this has negative performance implications due to lack of data locality)...\n\tfor ( i = 0; i < len; i++ ) {\n\t\tj = vind2bind( sh, sx, 0, ord, i, MODE );\n\t\tout.push( tmp[ j ] );\n\t}\n\treturn out;\n}\n\n\n// MAIN //\n\n/**\n* Flattens an n-dimensional nested array.\n*\n* ## Notes\n*\n* -   The function assumes that all nested arrays have the same length (i.e., the input array is **not** a ragged array).\n*\n* @param {Array} x - input nested array\n* @param {NonNegativeIntegerArray} shape - array shape\n* @param {boolean} colexicographic - specifies whether to flatten array values in colexicographic order\n* @returns {Array} flattened array\n*\n* @example\n* var x = [ [ 1, 2 ], [ 3, 4 ] ];\n*\n* var out = flatten( x, [ 2, 2 ], false );\n* // returns [ 1, 2, 3, 4 ]\n*\n* @example\n* var x = [ [ 1, 2 ], [ 3, 4 ] ];\n*\n* var out = flatten( x, [ 2, 2 ], true );\n* // returns [ 1, 3, 2, 4 ]\n*/\nfunction flatten( x, shape, colexicographic ) {\n\tvar ndims;\n\tvar out;\n\n\tndims = shape.length;\n\tout = [];\n\tif ( ndims === 0 ) { // 0-dimensional array\n\t\treturn out;\n\t}\n\tif ( ndims === 1 ) { // 1-dimensional array\n\t\t// For 1-dimensional arrays, we can perform a simple copy:\n\t\treturn copy( out, x, shape[ 0 ] );\n\t}\n\tif ( colexicographic ) {\n\t\treturn flattenColexicographic( out, x, ndims, shape );\n\t}\n\treturn recurseLexicographic( out, x, ndims, shape, 0 );\n}\n\n\n// EXPORTS //\n\nexport default flatten;\n"],"names":["copy","out","x","N","i","push","recurseLexicographic","ndims","shape","dim","FLG","S","d","flatten","colexicographic","length","len","tmp","ord","sh","sx","j","numel","shape2strides","grev","vind2bind","flattenColexicographic"],"mappings":";;4WAkDA,SAASA,EAAMC,EAAKC,EAAGC,GACtB,IAAIC,EACJ,IAAMA,EAAI,EAAGA,EAAID,EAAGC,IACnBH,EAAII,KAAMH,EAAGE,IAEd,OAAOH,CACR,CAaA,SAASK,EAAsBL,EAAKC,EAAGK,EAAOC,EAAOC,GACpD,IAAIC,EACAC,EACAC,EACAR,EAOJ,IAHAM,GADAE,EAAIH,EAAM,KACIF,EAEdI,EAAIH,EAAOC,GACLL,EAAI,EAAGA,EAAIO,EAAGP,IACdM,EACJT,EAAII,KAAMH,EAAGE,IAEbE,EAAsBL,EAAKC,EAAGE,GAAKG,EAAOC,EAAOI,GAGnD,OAAOX,CACR,CA2EA,SAASY,EAASX,EAAGM,EAAOM,GAC3B,IAAIP,EACAN,EAIJ,OADAA,EAAM,GACS,KAFfM,EAAQC,EAAMO,QAGNd,EAEO,IAAVM,EAEGP,EAAMC,EAAKC,EAAGM,EAAO,IAExBM,EA5EN,SAAiCb,EAAKC,EAAGK,EAAOC,GAC/C,IAAIQ,EACAC,EACAC,EACAC,EACAC,EACAC,EACAjB,EAsBJ,IAjBAa,EAAMX,EAAsB,GAAIJ,EAAGK,EAAOC,EAAO,GAGjDQ,EAAMM,EAAOd,GAMbY,EAAKG,EAAef,EAHpBU,EAAM,aAMNC,EAAKnB,EAAM,GAAIQ,EAAOD,GACtBiB,EAAMjB,EAAOY,EAAI,GACjBK,EAAMjB,EAAOa,EAAI,GAGXhB,EAAI,EAAGA,EAAIY,EAAKZ,IACrBiB,EAAII,EAAWN,EAAIC,EAAI,EAAGF,EAAKd,EApGtB,SAqGTH,EAAII,KAAMY,EAAKI,IAEhB,OAAOpB,CACR,CA2CSyB,CAAwBzB,EAAKC,EAAGK,EAAOC,GAExCF,EAAsBL,EAAKC,EAAGK,EAAOC,EAAO,EACpD"}