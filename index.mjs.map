{"version":3,"file":"index.mjs","sources":["../lib/assign.js","../lib/main.js","../lib/index.js"],"sourcesContent":["/**\n* @license Apache-2.0\n*\n* Copyright (c) 2023 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport shape2strides from '@stdlib/ndarray-base-shape2strides';\nimport vind2bind from '@stdlib/ndarray-base-vind2bind';\nimport numel from '@stdlib/ndarray-base-numel';\nimport grev from '@stdlib/blas-ext-base-grev';\nimport zeros from '@stdlib/array-base-zeros';\n\n\n// VARIABLES //\n\nvar MODE = 'throw';\n\n\n// FUNCTIONS //\n\n/**\n* Copies a specified number of array elements to a provided array.\n*\n* @private\n* @param {Array} x - input array\n* @param {NonNegativeInteger} N - number of elements to copy\n* @param {Collection} out - output array\n* @param {integer} stride - output array stride\n* @param {NonNegativeInteger} offset - output array offset\n*\n* @example\n* var x = [ 1, 2, 3, 4 ];\n*\n* var out = [ 0, 0, 0 ];\n* copy( x, 3, out, 1, 0 );\n*\n* var o = out;\n* // returns [ 1, 2, 3 ]\n*/\nfunction copy( x, N, out, stride, offset ) {\n\tvar i;\n\tfor ( i = 0; i < N; i++ ) {\n\t\tout[ offset ] = x[ i ];\n\t\toffset += stride;\n\t}\n}\n\n/**\n* Recursively flattens an array in lexicographic order.\n*\n* @private\n* @param {Array} x - array to flatten\n* @param {NonNegativeInteger} ndims - number of dimensions in the input array\n* @param {NonNegativeIntegerArray} shape - shape of the input array\n* @param {NonNegativeInteger} dim - dimension index\n* @param {Collection} out - output array\n* @param {integer} stride - output array stride\n* @param {NonNegativeInteger} offset - output array offset\n* @returns {NonNegativeInteger} offset for next output array element\n*/\nfunction recurseLexicographic( x, ndims, shape, dim, out, stride, offset ) {\n\tvar FLG;\n\tvar S;\n\tvar d;\n\tvar i;\n\n\t// Check whether we've reached the last dimension:\n\td = dim + 1;\n\tFLG = ( d === ndims );\n\n\tS = shape[ dim ];\n\tfor ( i = 0; i < S; i++ ) {\n\t\tif ( FLG ) {\n\t\t\tout[ offset ] = x[ i ];\n\t\t\toffset += stride;\n\t\t} else {\n\t\t\toffset = recurseLexicographic( x[ i ], ndims, shape, d, out, stride, offset ); // eslint-disable-line max-len\n\t\t}\n\t}\n\treturn offset;\n}\n\n/**\n* Flattens an array in colexicographic order.\n*\n* @private\n* @param {Array} x - array to flatten\n* @param {NonNegativeInteger} ndims - number of dimensions in the input array\n* @param {NonNegativeIntegerArray} shape - shape of the input array\n* @param {Collection} out - output array\n* @param {integer} stride - output array stride\n* @param {NonNegativeInteger} offset - output array offset\n*/\nfunction flattenColexicographic( x, ndims, shape, out, stride, offset ) {\n\tvar len;\n\tvar tmp;\n\tvar ord;\n\tvar sh;\n\tvar sx;\n\tvar j;\n\tvar i;\n\n\t// Note that, in contrast to lexicographic iteration, we cannot readily define a straightforward recursive definition for colexicographic iteration. Accordingly, we have to perform a workaround in which we first flatten in lexicographic order and then perform an out-of-place transposition to return an array in colexicographic order.\n\n\t// Determine how many elements will be in the output array:\n\tlen = numel( shape );\n\n\t// For input arrays having an arbitrary number of dimensions, first flatten in lexicographic order:\n\ttmp = zeros( len );\n\trecurseLexicographic( x, ndims, shape, 0, tmp, 1, 0 );\n\n\t// Define the memory layout:\n\tord = 'row-major';\n\n\t// Generate a stride array for lexicographic order:\n\tsx = shape2strides( shape, ord );\n\n\t// Reverse the dimensions and strides (i.e., define the shape and strides of the transpose):\n\tsh = zeros( ndims );\n\tcopy( shape, ndims, sh, 1, 0 );\n\tgrev( ndims, sh, 1 );\n\tgrev( ndims, sx, 1 );\n\n\t// Iterate over each element based on the linear **view** index (note: this has negative performance implications due to lack of data locality)...\n\tfor ( i = 0; i < len; i++ ) {\n\t\tj = vind2bind( sh, sx, 0, ord, i, MODE );\n\t\tout[ offset ] = tmp[ j ];\n\t\toffset += stride;\n\t}\n}\n\n\n// MAIN //\n\n/**\n* Flattens an n-dimensional nested array and assigns elements to a provided output array.\n*\n* ## Notes\n*\n* -   The function assumes that all nested arrays have the same length (i.e., the input array is **not** a ragged array).\n*\n* @param {Array} x - input nested array\n* @param {NonNegativeIntegerArray} shape - array shape\n* @param {boolean} colexicographic - specifies whether to flatten array values in colexicographic order\n* @param {Collection} out - output array\n* @param {integer} stride - output array stride\n* @param {NonNegativeInteger} offset - output array index offset\n* @returns {Collection} output array\n*\n* @example\n* import Float64Array from '@stdlib/array-float64';\n*\n* var x = [ [ 1, 2 ], [ 3, 4 ] ];\n*\n* var out = flatten( x, [ 2, 2 ], false, new Float64Array( 4 ), 1, 0 );\n* // returns <Float64Array>[ 1, 2, 3, 4 ]\n*\n* @example\n* import Float64Array from '@stdlib/array-float64';\n*\n* var x = [ [ 1, 2 ], [ 3, 4 ] ];\n*\n* var out = flatten( x, [ 2, 2 ], true, new Float64Array( 4 ), 1, 0 );\n* // returns <Float64Array>[ 1, 3, 2, 4 ]\n*/\nfunction flatten( x, shape, colexicographic, out, stride, offset ) {\n\tvar ndims = shape.length;\n\tif ( ndims === 0 ) { // 0-dimensional array\n\t\treturn out;\n\t}\n\tif ( ndims === 1 ) { // 1-dimensional array\n\t\t// For 1-dimensional arrays, we can perform a simple copy:\n\t\tcopy( x, shape[ 0 ], out, stride, offset );\n\t\treturn out;\n\t}\n\tif ( colexicographic ) {\n\t\tflattenColexicographic( x, ndims, shape, out, stride, offset );\n\t\treturn out;\n\t}\n\trecurseLexicographic( x, ndims, shape, 0, out, stride, offset );\n\treturn out;\n}\n\n\n// EXPORTS //\n\nexport default flatten;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2023 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport numel from '@stdlib/ndarray-base-numel';\nimport zeros from '@stdlib/array-base-zeros';\nimport assign from './assign.js';\n\n\n// MAIN //\n\n/**\n* Flattens an n-dimensional nested array.\n*\n* ## Notes\n*\n* -   The function assumes that all nested arrays have the same length (i.e., the input array is **not** a ragged array).\n*\n* @param {Array} x - input nested array\n* @param {NonNegativeIntegerArray} shape - array shape\n* @param {boolean} colexicographic - specifies whether to flatten array values in colexicographic order\n* @returns {Array} flattened array\n*\n* @example\n* var x = [ [ 1, 2 ], [ 3, 4 ] ];\n*\n* var out = flatten( x, [ 2, 2 ], false );\n* // returns [ 1, 2, 3, 4 ]\n*\n* @example\n* var x = [ [ 1, 2 ], [ 3, 4 ] ];\n*\n* var out = flatten( x, [ 2, 2 ], true );\n* // returns [ 1, 3, 2, 4 ]\n*/\nfunction flatten( x, shape, colexicographic ) {\n\tvar out = zeros( numel( shape ) );\n\treturn assign( x, shape, colexicographic, out, 1, 0 );\n}\n\n\n// EXPORTS //\n\nexport default flatten;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2023 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n/**\n* Flatten an n-dimensional nested array.\n*\n* @module @stdlib/array-base-flatten\n*\n* @example\n* import flatten from '@stdlib/array-base-flatten';\n*\n* var x = [ [ 1, 2 ], [ 3, 4 ] ];\n*\n* var out = flatten( x, [ 2, 2 ], false );\n* // returns [ 1, 2, 3, 4 ]\n*\n* @example\n* import flatten from '@stdlib/array-base-flatten';\n*\n* var x = [ [ 1, 2 ], [ 3, 4 ] ];\n*\n* var out = flatten( x, [ 2, 2 ], true );\n* // returns [ 1, 3, 2, 4 ]\n*\n* @example\n* import Float64Array from '@stdlib/array-float64';\n* import flatten from '@stdlib/array-base-flatten';\n*\n* var x = [ [ 1, 2 ], [ 3, 4 ] ];\n*\n* var out = new Float64Array( 4 );\n* var y = flatten.assign( x, [ 2, 2 ], true, out, 1, 0 );\n* // returns <Float64Array>[ 1, 3, 2, 4 ]\n*\n* var bool = ( y === out );\n* // returns true\n*/\n\n// MODULES //\n\nimport setReadOnly from '@stdlib/utils-define-nonenumerable-read-only-property';\nimport main from './main.js';\nimport assign from './assign.js';\n\n\n// MAIN //\n\nsetReadOnly( main, 'assign', assign );\n\n\n// EXPORTS //\n\nexport default main;\n"],"names":["copy","x","N","out","stride","offset","i","recurseLexicographic","ndims","shape","dim","FLG","S","d","flatten","colexicographic","length","len","tmp","ord","sh","sx","j","numel","zeros","shape2strides","grev","vind2bind","flattenColexicographic","assign","setReadOnly","main"],"mappings":";;ijBAuDA,SAASA,EAAMC,EAAGC,EAAGC,EAAKC,EAAQC,GACjC,IAAIC,EACJ,IAAMA,EAAI,EAAGA,EAAIJ,EAAGI,IACnBH,EAAKE,GAAWJ,EAAGK,GACnBD,GAAUD,CAEZ,CAeA,SAASG,EAAsBN,EAAGO,EAAOC,EAAOC,EAAKP,EAAKC,EAAQC,GACjE,IAAIM,EACAC,EACAC,EACAP,EAOJ,IAHAK,GADAE,EAAIH,EAAM,KACIF,EAEdI,EAAIH,EAAOC,GACLJ,EAAI,EAAGA,EAAIM,EAAGN,IACdK,GACJR,EAAKE,GAAWJ,EAAGK,GACnBD,GAAUD,GAEVC,EAASE,EAAsBN,EAAGK,GAAKE,EAAOC,EAAOI,EAAGV,EAAKC,EAAQC,GAGvE,OAAOA,CACR,CAqFA,SAASS,EAASb,EAAGQ,EAAOM,EAAiBZ,EAAKC,EAAQC,GACzD,IAAIG,EAAQC,EAAMO,OAClB,OAAe,IAAVR,EACGL,EAEO,IAAVK,GAEJR,EAAMC,EAAGQ,EAAO,GAAKN,EAAKC,EAAQC,GAC3BF,GAEHY,GAlFN,SAAiCd,EAAGO,EAAOC,EAAON,EAAKC,EAAQC,GAC9D,IAAIY,EACAC,EACAC,EACAC,EACAC,EACAC,EACAhB,EAwBJ,IAnBAW,EAAMM,EAAOd,GAIbF,EAAsBN,EAAGO,EAAOC,EAAO,EADvCS,EAAMM,EAAOP,GACkC,EAAG,GAMlDI,EAAKI,EAAehB,EAHpBU,EAAM,aAONnB,EAAMS,EAAOD,EADbY,EAAKI,EAAOhB,GACY,EAAG,GAC3BkB,EAAMlB,EAAOY,EAAI,GACjBM,EAAMlB,EAAOa,EAAI,GAGXf,EAAI,EAAGA,EAAIW,EAAKX,IACrBgB,EAAIK,EAAWP,EAAIC,EAAI,EAAGF,EAAKb,EA9GtB,SA+GTH,EAAKE,GAAWa,EAAKI,GACrBjB,GAAUD,CAEZ,CA+CEwB,CAAwB3B,EAAGO,EAAOC,EAAON,EAAKC,EAAQC,GAC/CF,IAERI,EAAsBN,EAAGO,EAAOC,EAAO,EAAGN,EAAKC,EAAQC,GAChDF,EACR,CChJA,SAASW,EAASb,EAAGQ,EAAOM,GAE3B,OAAOc,EAAQ5B,EAAGQ,EAAOM,EADfS,EAAOD,EAAOd,IACuB,EAAG,EACnD,CCQAqB,EAAAC,EAAA,SAAAF"}